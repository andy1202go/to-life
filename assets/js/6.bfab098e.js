(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{385:function(n,r,a){n.exports=a.p+"assets/img/image-20211101232638505.7e0176a1.png"},415:function(n,r,a){"use strict";a.r(r);var e=a(4),i=Object(e.a)({},(function(){var n=this,r=n._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h1",{attrs:{id:"spring实战-第4版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spring实战-第4版"}},[n._v("#")]),n._v(" Spring实战（第4版）")]),n._v(" "),r("p",[n._v("有核心原理的介绍，比较适合入门。")]),n._v(" "),r("ul",[r("li",[n._v("目的：简化JavaEE的开发")]),n._v(" "),r("li",[n._v("路线图：Spring核心，SpringWeb，Spring持久化")])]),n._v(" "),r("h2",{attrs:{id:"第1部分-spring的核心"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第1部分-spring的核心"}},[n._v("#")]),n._v(" 第1部分　Spring的核心")]),n._v(" "),r("h3",{attrs:{id:"第1章-spring之旅-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第1章-spring之旅-3"}},[n._v("#")]),n._v(" 第1章　Spring之旅　3")]),n._v(" "),r("h4",{attrs:{id:"_1-1-简化java开发-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-简化java开发-4"}},[n._v("#")]),n._v(" 1.1　简化Java开发　4")]),n._v(" "),r("h5",{attrs:{id:"_1-1-1-激发pojo的潜能-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-激发pojo的潜能-5"}},[n._v("#")]),n._v(" 1.1.1　激发POJO的潜能　5")]),n._v(" "),r("h5",{attrs:{id:"_1-1-2-依赖注入-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-依赖注入-5"}},[n._v("#")]),n._v(" 1.1.2　依赖注入　5")]),n._v(" "),r("h5",{attrs:{id:"_1-1-3-应用切面-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-3-应用切面-11"}},[n._v("#")]),n._v(" 1.1.3　应用切面　11")]),n._v(" "),r("h5",{attrs:{id:"_1-1-4-使用模板消除样板式代码-16"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-4-使用模板消除样板式代码-16"}},[n._v("#")]),n._v(" 1.1.4　使用模板消除样板式代码　16")]),n._v(" "),r("h4",{attrs:{id:"_1-2-容纳你的bean-18"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-容纳你的bean-18"}},[n._v("#")]),n._v(" 1.2　容纳你的Bean　18")]),n._v(" "),r("h5",{attrs:{id:"_1-2-1-使用应用上下文-19"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-1-使用应用上下文-19"}},[n._v("#")]),n._v(" 1.2.1　使用应用上下文　19")]),n._v(" "),r("h5",{attrs:{id:"_1-2-2-bean的生命周期-20"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-2-bean的生命周期-20"}},[n._v("#")]),n._v(" 1.2.2　bean的生命周期　20")]),n._v(" "),r("p",[n._v("1.3　俯瞰Spring风景线　21\n1.3.1　Spring模块　22\n1.3.2　Spring Portfolio　24\n1.4　Spring的新功能　27\n1.4.1　Spring 3.1新特性　27\n1.4.2　Spring 3.2新特性　28\n1.4.3　Spring 4.0新特性　30\n1.5　小结　30\n第2章　装配Bean　33\n2.1　Spring配置的可选方案　34\n2.2　自动化装配bean　35\n2.2.1　创建可被发现的bean　35\n2.2.2　为组件扫描的bean命名　38\n2.2.3　设置组件扫描的基础包　39\n2.2.4　通过为bean添加注解实现自动装配　40\n2.2.5　验证自动装配　42\n2.3　通过Java代码装配\nbean　44\n2.3.1　创建配置类　44\n2.3.2　声明简单的bean　45\n2.3.3　借助JavaConfig实现注入　46\n2.4　通过XML装配bean　48\n2.4.1　创建XML配置规范　48\n2.4.2　声明一个简单的\n[bean]　49\n2.4.3　借助构造器注入初始化bean　50\n2.4.4　设置属性　56\n2.5　导入和混合配置　61\n2.5.1　在JavaConfig中引用XML配置　61\n2.5.2　在XML配置中引用JavaConfig　63\n2.6　小结　65\n第3章　高级装配　67\n3.1　环境与profile　67\n3.1.1　配置profile bean　69\n3.1.2　激活profile　73\n3.2　条件化的bean　75\n3.3　处理自动装配的歧义性　78\n3.3.1　标示首选的bean　79\n3.3.2　限定自动装配的bean　80\n3.4　bean的作用域　84\n3.4.1　使用会话和请求作用域　86\n3.4.2　在XML中声明作用域代理　88\n3.5　运行时值注入　88\n3.5.1　注入外部的值　89\n3.5.2　使用Spring表达式语言进行装配　93\n3.6　小结　99\n第4章　面向切面的Spring　101\n4.1　什么是面向切面编程？　102\n4.1.1　定义AOP术语　103\n4.1.2　Spring对AOP的支持　105\n4.2　通过切点来选择连接点　107\n4.2.1　编写切点　108\n4.2.2　在切点中选择bean　109\n4.3　使用注解创建切面　109\n4.3.1　定义切面　110\n4.3.2　创建环绕通知　114\n4.3.3　处理通知中的参数　115\n4.3.4　通过注解引入新功能　118\n4.4　在XML中声明切面　120\n4.4.1　声明前置和后置通知　122\n4.4.2　声明环绕通知　124\n4.4.3　为通知传递参数　125\n4.4.4　通过切面引入新的功能　127\n4.5　注入AspectJ切面　128\n4.5　小结　131")]),n._v(" "),r("h3",{attrs:{id:"第2部分-web中的spring"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第2部分-web中的spring"}},[n._v("#")]),n._v(" 第２部分　Web中的Spring")]),n._v(" "),r("ul",[r("li",[n._v("SpringMVC是构建在Spring理念之上的一个Web框架")]),n._v(" "),r("li",[n._v("基础用法")]),n._v(" "),r("li",[n._v("渲染视图")]),n._v(" "),r("li",[n._v("高级技术：自定义配置，multipart文件上传等")]),n._v(" "),r("li",[n._v("工作流")])]),n._v(" "),r("h4",{attrs:{id:"第5章-构建spring-web应用程序-135"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第5章-构建spring-web应用程序-135"}},[n._v("#")]),n._v(" 第5章　构建Spring Web应用程序　135")]),n._v(" "),r("ul",[r("li",[n._v("针对基于Web的应用程序")]),n._v(" "),r("li",[n._v("HTTP的无状态性决定了状态管理、工作流、验证等不容易处理")]),n._v(" "),r("li",[n._v("SpringMVC基于MVC模式")])]),n._v(" "),r("h5",{attrs:{id:"_5-1-spring-mvc起步-136"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-spring-mvc起步-136"}},[n._v("#")]),n._v(" 5.1　Spring MVC起步　136")]),n._v(" "),r("p",[r("strong",[n._v("先定个基调：Spring MVC中的组件都有特定的目的，并且也没有那么复杂！")])]),n._v(" "),r("h6",{attrs:{id:"_5-1-1-跟踪spring-mvc的请求-136"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-跟踪spring-mvc的请求-136"}},[n._v("#")]),n._v(" 5.1.1　跟踪Spring MVC的请求　136")]),n._v(" "),r("p",[r("img",{attrs:{src:a(385),alt:"image-20211101232638505"}})]),n._v(" "),r("p",[r("strong",[n._v("7部曲")])]),n._v(" "),r("ol",[r("li",[n._v("前端控制器（DispatcherServlet）接收请求")]),n._v(" "),r("li",[n._v("处理器映射（Handler），根据URL决策Controller是哪个")]),n._v(" "),r("li",[n._v("前端控制器把请求发给处理器映射找到的Controller，控制器处理请求")]),n._v(" "),r("li",[n._v("控制器处理后的信息，称为模型（Model）；控制器将模型数据打包，并标示出用于渲染输出的视图名，发回给前端控制器")]),n._v(" "),r("li",[n._v("DispatcherServlet使用视图解析器（view resolver）将逻辑视图名匹配为一个特定的视图实现")]),n._v(" "),r("li",[n._v("视图的实现，在这里交付模型数据，完成请求的任务")]),n._v(" "),r("li",[n._v("视图将使用模型数据渲染输出，通过响应对象传递给客户端")])]),n._v(" "),r("p",[n._v("5.1.2　搭建Spring MVC　138\n5.1.3　Spittr应用简介　142\n5.2　编写基本的控制器　143\n5.2.1　测试控制器　145\n5.2.2　定义类级别的请求处理　146\n5.2.3　传递模型数据到视图中　147\n5.3　接受请求的输入　153\n5.3.1　处理查询参数　153\n5.3.2　通过路径参数接受输入　155\n5.4　处理表单　157\n5.4.1　编写处理表单的控制器　160\n5.4.2　校验表单　163\n5.5　小结　166")]),n._v(" "),r("h4",{attrs:{id:"第6章-渲染web视图-167"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第6章-渲染web视图-167"}},[n._v("#")]),n._v(" 第6章　渲染Web视图　167")]),n._v(" "),r("p",[n._v("6.1　理解视图解析　167\n6.2　创建JSP视图　170\n6.2.1　配置适用于JSP的视图解析器　170\n6.2.2　使用Spring的JSP库　172\n6.3　使用Apache Tiles视图定义布局　184\n6.3.1　配置Tiles视图解析器　185\n6.4　使用Thymeleaf　190\n6.4.1　配置Thymeleaf视图解析器　190\n6.4.2　定义Thymeleaf模板　192\n6.5　小结　196")]),n._v(" "),r("h4",{attrs:{id:"第7章-spring-mvc的高级技术-197"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第7章-spring-mvc的高级技术-197"}},[n._v("#")]),n._v(" 第7章　Spring MVC的高级技术　197")]),n._v(" "),r("p",[n._v("7.1　Spring MVC配置的替代方案　198\n7.1.1　自定义DispatcherServlet配置　198\n7.1.2　添加其他的Servlet和Filter　199\n7.1.3　在web.xml中声明DispatcherServlet　201\n7.2　处理multipart形式的数据　204\n7.2.1　配置multipart解析器　205\n7.2.2　处理multipart请求　208\n7.3　处理异常　212\n7.3.1　将异常映射为HTTP状态码　213\n7.3.2　编写异常处理的方法　214\n7.4　为控制器添加通知　216\n7.5　跨重定向请求传递数据　217\n7.5.1　通过URL模板进行重定向　218\n7.5.2　使用flash属性　219\n7.6　小结　221")]),n._v(" "),r("h4",{attrs:{id:"第8章-使用spring-webflow-223"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第8章-使用spring-webflow-223"}},[n._v("#")]),n._v(" 第8章　使用Spring WebFlow　223")]),n._v(" "),r("p",[n._v("8.1　在Spring中配置Web　Flow　224\n8.1.1　装配流程执行器　224\n8.1.2　配置流程注册表　224\n8.1.3　处理流程请求　225\n8.2　流程的组件　226\n8.2.1　状态　226\n8.2.2　转移　230\n8.2.3　流程数据　231\n8.3　组合起来：披萨流程　232\n8.3.1　定义基本流程　233\n8.3.2　收集顾客信息　236\n8.3.2　构建订单　242\n8.3.2　支付　244\n8.4　保护Web流程　246\n8.5　小结　246")]),n._v(" "),r("h4",{attrs:{id:"第9章-保护web应用-249"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第9章-保护web应用-249"}},[n._v("#")]),n._v(" 第9章　保护Web应用　249")]),n._v(" "),r("p",[n._v("9.1　Spring Security简介　250\n9.1.1　理解Spring Security的模块　250\n9.1.2　过滤Web请求　251\n9.1.3　编写简单的安全性配置　252\n9.2　选择查询用户详细信息的服务　255\n9.2.1使用基于内存的用户存储　255\n9.2.2　基于数据库表进行认证　257\n9.2.3　基于LDAP进行认证　259\n9.2.4　配置自定义的用户服务　263\n9.3　拦截请求　265\n9.3.1　使用Spring表达式进行安全保护　267\n9.3.2　强制通道的安全性　269\n9.3.3　防止跨站请求伪造　270\n9.4　认证用户　271\n9.4.1　添加自定义的登录页　272\n9.4.2　启用HTTP Basic认证　274\n9.4.3　启用Remember-me功能　274\n9.4.4　退出　275\n9.5　保护视图　276\n9.5.1　使用Spring Security的JSP标签库　276\n9.5.2　使用Thymeleaf的SpringSecurity方言　280\n9.6　小结　281\n第3部分　后端中的Spring\n第10章　通过Spring和JDBC征服数据库　285\n10.1　Spring的数据访问哲学　286\n10.1.1　了解Spring的数据访问异常体系　287\n10.1.2　数据访问模板化　289\n10.2　配置数据源　291\n10.2.1　使用JNDI数据源　292\n10.2.2　使用数据源连接池　292\n10.2.3　基于JDBC驱动的数据源　294\n10.2.4　使用嵌入式的数据源　295\n10.2.5　使用profile选择数据源　296\n10.3　在Spring中使用\nJDBC　298\n10.3.1　应对失控的JDBC代码　299\n10.3.2　使用JDBC模板　302\n10.4　小结　307\n第11章　使用对象-关系映射持久化数据　309\n11.1　在Spring中集成Hibernate　310\n11.1.1　声明Hibernate的Session工厂　311\n11.1.2　构建不依赖于Spring的Hibernate代码　313\n11.2　Spring与Java持久化API　315\n11.2.1　配置实体管理器工厂　315\n11.2.2　编写基于JPA的Repository　320\n11.3　借助Spring Data实现自动化的JPA　Repository　322\n11.3.1　定义查询方法　325\n11.3.2　声明自定义查询　328\n11.3.3　混合自定义的功能　329\n11.4　小结　330\n第12章　使用NoSQL数据库　333\n12.1　使用MongoDB持久化文档数据　334\n12.1.1　启用MongoDB　335\n12.1.2　为模型添加注解，实现MongoDB持久化　338\n12.1.3　使用MongoTemplate访问MongoDB　341\n12.1.4　编写MongoDBRepository　342\n12.2　使用Neo4j操作图数据　347\n12.2.1　配置Spring DataNeo4j　347\n12.2.2　使用注解标注图实体　350\n12.2.3　使用Neo4jTemplate　353\n12.2.4　创建自动化的Neo4j　Repository　354\n12.3　使用Redis操作key-value数据　359\n12.3.1　连接到Redis　359\n12.3.2　使用RedisTemplate　360\n12.3.3　使用key和value的序列化器　364\n12.4　小结　365\n第13章　缓存数据　367\n13.1　启用对缓存的支持　368\n13.1.1　配置缓存管理器　369\n13.2　为方法添加注解以支持缓存　373\n13.2.1　填充缓存　374\n13.2.2　移除缓存条目　378\n13.3　使用XML声明缓存　379\n13.4　小结　383\n第14章　保护方法应用　385\n14.1　使用注解保护方法　386\n14.1.1　使用@Secured注解限制方法调用　386\n14.1.2　在Spring Security中使用\nJSR-250的@RolesAllowed注解　387\n14.2　使用表达式实现方法级别的安全性　388\n14.2.1　表述方法访问规则　389\n14.2.2　过滤方法的输入和输出　391\n14.3　小结　395\n第4部分　Spring集成\n第15章　使用远程服务　399\n15.1　Spring远程调用概览　400\n15.2　使用RMI　402\n15.2.1　导出RMI服务　403\n15.2.2　装配RMI服务　405\n15.3　使用Hessian和Burlap发布远程服务　407\n15.3.1　使用Hessian和Burlap导出bean的功能　408\n15.3.2　访问Hessian/Burlap服务　411\n15.4　使用Spring的HttpInvoker　413\n15.4.1　将bean导出为HTTP服务　413\n15.4.2　通过HTTP访问服务　414\n15.5　发布和使用Web服务　416\n15.5.1　创建基于Spring的JAX-WS端点　416\n15.5.2　在客户端代理JAX-WS服务　419\n15.6　小结　421\n第16章　使用Spring MVC创建REST API　423\n16.1　了解REST　424\n16.1.1　REST的基础知识　424\n16.1.2　Spring是如何支持REST的　425\n16.2　创建第一个REST端点　426\n16.2.1　协商资源表述　428\n16.2.2　使用HTTP信息转换器　433\n16.3　提供资源之外的其他内容　438\n16.3.1　发送错误信息到客户端　438\n16.3.2　在响应中设置头部信息　443\n16.4　编写REST客户端　445\n16.4.1　了解RestTemplate的操作　446\n16.4.2　GET资源　447\n16.4.3　检索资源　448\n16.4.4　抽取响应的元数据　449\n16.4.5　PUT资源　450\n16.4.6　DELETE资源　451\n16.4.7　POST资源数据　452\n16.4.8　在POST请求中获取响应对象　452\n16.4.9　在POST请求后获取资源位置　453\n16.4.10　交换资源　454\n16.5　小结　456\n第17章　Spring消息　457\n17.1　异步消息简介　458\n17.1.1　发送消息　459\n17.1.2　评估异步消息的优点　461\n17.2　使用JMS发送消息　463\n17.2.1　在Spring中搭建消息代理　463\n17.2.2　使用Spring的JMS模板　465\n17.2.3　创建消息驱动的POJO　474\n17.2.4　使用基于消息的RPC　477\n17.3　使用AMQP实现消息功能　479\n17.3.1　AMQP简介　480\n17.3.2　配置Spring支持AMQP消息　481\n17.3.3　使用RabbitTemplate发送消息　484\n17.3.4　接收AMQP消息　486\n17.4　小结　489\n第18章　使用WebSocket和STOMP实现消息功能　491\n18.1　使用Spring的低层级WebSocket　API　492\n18.2　应对不支持WebSocket的场景　497\n18.3　使用STOMP消息　500\n18.3.1　启用STOMP消息功能　501\n18.3.2　处理来自客户端的STOMP消息　504\n18.3.3　发送消息到客户端　507\n18.4　为目标用户发送消息　511\n18.4.1　在控制器中处理用户的消息　512\n18.4.2　为指定用户发送消息　514\n18.5　处理消息异常　515\n18.6　小结　516\n第19章　使用Spring发送Email　517\n19.1　配置Spring发送邮件　518\n19.1.1　配置邮件发送器　518\n19.1.2　装配和使用邮件发送器　520\n19.2　构建丰富内容的Email消息　521\n19.2.1　添加附件　521\n19.2.2　发送富文本内容的Email　522\n19.3　使用模板生成Email　524\n19.3.1　使用Velocity构建Email消息　524\n19.3.2　使用Thymeleaf构建Email消息　526\n19.4　小结　528\n第20章　使用JMX管理Spring　Bean　529\n20.1　将Spring bean导出为MBean　530\n20.1.1　通过名称暴露方法　533\n20.1.2　使用接口定义MBean的操作和属性　535\n20.1.3　使用注解驱动的MBean　536\n20.1.4　处理MBean冲突　538\n20.2　远程MBean　539\n20.2.1　暴露远程MBean　539\n20.2.2　访问远程MBean　540\n20.2.3　代理MBean　542\n20.3　处理通知　543\n20.3.1　监听通知　544\n20.4　小结　545\n第21章　借助Spring Boot简化Spring开发　547\n21.1　Spring Boot简介　548\n21.1.1　添加Starter依赖　548\n21.1.2　自动配置　552\n21.1.3　Spring Boot CLI　552\n21.1.4　Actuator　553\n21.2　使用Spring Boot构建应用　553\n21.2.1　处理请求　556\n21.2.2　创建视图　558\n21.2.3　添加静态内容　560\n21.2.4　持久化数据　561\n21.2.5　尝试运行　563\n21.3　组合使用Groovy与SpringBoot　CLI　566\n21.3.1　编写Groovy控制器　566\n21.3.2　使用Groovy Repository实现数据持久化　569\n21.3.3　运行Spring Boot CLI　570\n21.4　通过Actuator获取了解应用内部状况　571\n21.5　小结　574")])])}),[],!1,null,null,null);r.default=i.exports}}]);